#include "amldec.h"

#define _ALIGN_(x, mask)    (((x) + (mask)) & ~(mask))
#define ALIGN(x, a)         _ALIGN_(x, (typeof(x))(a) - 1)

DEC_CONFIG_t dec_conf;
AMLDEC_HANDLE_t vdec_handle;

/*Step 1: Initialize the video decoder*/
memset(&dec_conf, 0, sizeof(DEC_CONFIG_t));

dec_conf.play_id     = <playback channel id: 1, 2, 3, 4 ...>;
dec_conf.format      = <DEC_FORMAT_t defined in amldec.h.
                        the default hardware decoding output is VDEC_FORMAT_NV12>;
dec_conf.src_width   = ALIGN(<original video width>, 32);
dec_conf.src_height  = ALIGN(<original video height>, 32);

dec_conf.dest_width  = <expected output video width>;
dec_conf.dest_height = <expected output video height>;

dec_conf.tbuf        = kVdecBuffer_MEM;
dec_conf.opaque      = <application private data OR NULL>;

vdec_handle = amlDecInit(&dec_conf);
if (!vdec_handle) {
    //success
} else {
    //failure
}

/*Step 2: Start the video decoder*/
int rc;
rc = amlDecStart(vdec_handle);
if (rc == 0) {
    //success
} else {
    //failure
}

/*Step 3: Feed the video ES packages into the video decoder continuously*/
2 options currently are supported
1) Gstreamer: GstSample *frame
GstFlowReturn status = GST_FLOW_ERROR;
status = amlDecSendData(vdec_handle, sample, DEC_DATA_GST);
if (status != GST_FLOW_OK) {
    //failure
} else {
    //success
}

2) AMLDEC_DATA_t *frame
AMLDEC_DATA_t *frame;
frame->codec        = <DEC_CODEC_t>;
frame->is_key_frame = <1: I frame, 0: P/B frames>;
frame->pts_us       = <64-bit pts in us>;
frame->data         = <Video ES Package Data Buffer>;
frame->size         = <Size of the video buffer>;

status = amlDecSendData(vdec_handle, sample, DEC_DATA_SPEC);
if (status) {
    //failure
} else {
    //success
}

Note: ffmpeg AVPacket* pkt is not supported right now and planned to be supported in
      the future.


/*Step 4: Start the thread to recieve the decoded picture whenever it is ready*/
DEC_FRAME_t *frame;
mlDecReceiveFrame(vdec_handle, &frame);

/*
VDEC_FORMAT_NV12:
    frame->buf[0]: YYYY...
    frame->buf[1]: UV...

VDEC_FORMAT_NV21:
    frame->buf[0]: YYYY...
    frame->buf[1]: VU...

VDEC_FORMAT_I420:
    frame->buf[0]: YYYY...
    frame->buf[1]: U...
    frame->buf[2]: V...

VDEC_FORMAT_RGB/VDEC_FORMAT_BGR/VDEC_FORMAT_RGBA...
    frame->buf[0]
*/

/*Need to release it once you used it up*/
amlDecReleaseFrame(rt->vdec_handle, frame);

/*Step 5: Stop the video decoder*/
1) stop to feed the video data into decoder
2) amlDecStop(vdec_handle);

/*Step 6: Release the video decoder*/
amlDecRelease(vdec_handle);